<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kxxpa</title>
    <link rel="icon" type="image/png" href="images\K.png"/>
    <link rel="stylesheet" href="css/style.css">
    <link rel="preload" href="winbox.bundle.min.js" as="script">
    <link
    rel="stylesheet"
    href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/xt256.min.css"
    />
    <!-- qtcreator-dark -->
</head>
<body>
    <div class="topbar">
        <h1> Tyler Thompson </h1>
    </div>
    <div class="blog_window">
        <div id="blog_selector" class="blog_selector">
            <div class="blog_selector_title">
                FILES
            </div>
            <div style="margin: 35px;"></div>
            <div id="blog_files_content" class="blog_files_content">
                <button class="root_file" id="root_button">
                    <img src="folder.png" class="file_image">
                    <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Blog:/></p>
                </button>
                <div></div>
                <div id="second_column" class="column"> 
                    <button id="OS_file" class="seconditem">
                        <img src="folder.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">OS_Work:/></p>
                    </button>
                    <div id="os_column" class="column" style="display: none;">
                        <button id="os_part1_button" class="thirditem">
                            <img src="file.png" class="file_image">
                            <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Part I : Intro</p>
                        </button>
                        <button id="os_part2_button" class="thirditem">
                            <img src="file.png" class="file_image">
                            <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Part II : Bootloading</p>
                        </button>
                        <button id="os_part3_button" class="thirditem">
                            <img src="file.png" class="file_image">
                            <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Part III : Learning about x86</p>
                        </button>
                    </div>
                    <a href="https://github.com/kxxpa">
                    <button href="https://www.w3schools.com" id="github_button" class="seconditem">
                        <img src="file.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Github.ty</p>
                    </button>
                    </a>
                    <button id="contact_button" class="seconditem">
                        <img src="file.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Contact.ty</p>
                    </button>
                    <button id="about_button" class="seconditem">
                        <img src="file.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">About.ty</p>
                    </button>
                </div>
            </div>
        </div>

        <div id="blog_viewer" class="blog_viewer">
            <div class="blog_selector_title">
                VIEWER
            </div>
            <div id="blog_content" class="blog_content" style="margin-top: 35px;">
                <h2>Use the files to view content within my blog</h2>
            </div>
        </div>
    </div>
    <div id="backstore" style="display: none;">
        <div id="about_content">
            <h2>about_me:#<span class="cursor"></span></h2>
            <p>My name is Tyler Thompson, I go online as Kxxpa, I have been programming for 5 years</p>
            <p>I am fluent in many programming languages, these include C++, Python, Rust. My favorite one is split between Rust and C++.</p>
            <p>Programming is what i mainly do in my freetime, I love it, I've made many projects that i've just done for fun.</p>
            <p>These include stuff like: A ray tracer, an abstract syntax tree programming language, a chip 8 interpreter, and i'm probably making more projects as you're reading this.</p>
        </div>
        <div id="contact_content" class="info_pages">
            <h2>contact_me:#<span class="cursor"></span></h2>
            <p>You can contact me for any reason whatsoever, if you want to collaborate on a project, work with me or just want to talk. Go ahead!</p>
            <p>You can send me an email over at koopahello@gmail.com</p>
        </div>
        <div id="os1_content">
            <h1 style="font-size: 40px;"><u>Making an OS using NASM and C</u></h1>
            <h1>Part I : Intro</h1>
            <h2>Preface</h2>
            <p>After looking at the os-dev wiki, I found many of the tutorials to be extremely confusing and aimless.
                and making my own operating system has always been a plan of mine. At the time of writing,
                I have very little knowledge on how to make bootloaders and kernels (which is probably why os-dev has been so confusing for me).
                And there are also very few resources online on how to make operating systems; they are either 1000-page university-level documents that
                Don’t start at boot loading and mainly focus on the theory behind processes and paging, many operating concepts that will take months of
                reading to get through, or are unfinished or small documents that do not provide enough info.</p>

            <p>Surprisingly, there are only a couple things online that are aimed at getting beginners started on operating system development.
                I aim to try and demystify the process of writing your own operating system in this blog without it taking up too much of your time.
                If there are any problems or things that confuse you in any of my articles, please email me about them, as I am eager to improve both my technical writing and programming.</p>

            <p>Although this series of articles is aimed at beginners, I recommend making sure you know a bit about how any flavor of assembly works.
                and how C works. That’s all the required knowledge you would need to get started.</p>

            <p>Another thing to say is that I intend to use my writing style to only give you the necessary points for understanding the code.
                behind a lot of the aspects behind OS development and not actually go into depth about all these types of topics, but I probably will write
                a few articles about the theory behind it all, as that is required to understand how BIOS and CPU architecture work, to start writing OS stuff.</p>

            <h2>Specifications</h2>

            <p>My operating system will work on x86 CPUs, will be stored on a virtual floppy disk, and will be made using C and ASM.
                There will also be some other tools being used in order to make the development process a lot easier. Such as GDB,
                to debug whatever I write, Makefiles in order to build the project fast, and qemu in order to run the OS without having to reboot my system repeatedly.</p>

            <h2>Getting started : What's first?</h2>

            <p>The first step in making an operating system is to either set up or make a bootloader.
                I will be making one; if you wanted to set one up, you could probably set up the kernel you write with GRUB.
                In order to make a bootloader, there will only be 3 steps.</p>

            <p>Step 1: printing in bios that we are booting the OS.</p>
            <p>Step 2: reading the hard disk in the right place and loading the kernel into memory (in bios).</p>
            <p>Step 3: giving access to the kernel, by jumping to where we loaded the kernel into memory (still in bios).</p>

            <p>We also need to remember that we are programming assembly without an operating system.
                This means that we can’t use any OS interrupts in order to print to the screen, read from certain file locations,
                or anything else we would have taken for granted when doing our regular programming.</p>

            <p>This is a good decomposition of the problem of writing our own bootloader; even now, you could even stop reading.
                and google how to do these steps or even ask ChatGPT, it’s good to decompose problems for a massive subject like making your own OS,
                It can help us learn about the aspects rather than being overwhelmed with information when we google “how to make a bootloader."
                We can google “how to print to bios in NASM” and “how to read from a hard disc in bios NASM.”.</p>

            <p>Even printing is complex without an operating system, so don’t get hung up if you take an hour trying to do any aspect of what
                we’re doing, especially if you’re just sitting there trying to understand some instructions or code (I have done this many times).</p>

            <p>In the next chapter, I will cover and go step by step with you on how to produce the bootloader using the steps I have laid out.</p>
        </div>
        <div id="os2_content">
            <h1>Part II : Bootloading</h1>
            <h2>A few words...</h2>
            <p>If you love coding, you're probably eager to get straight into the programming and make something that functions, well good news, in this chapter we will end with a
                fully functioning bootloader, that loads into a simple kernel that just loads a hello world message. How exciting!</p>
            
            <p>This also shouldn't take that many lines of code, although the instructions can be very complex, which i will try to explain to the best of my ability in this chapter.</p>

            <p>Sadly, if you like a hands on experience, the next chapter will cover alot of theory, but i will try to make it as consise and quick as possible, as i only try to cover
                key points, that you can research later if you have any interest.</p>

            <h2>Printing in BIOS</h2>

            <p>Mainly, to demonstrate how things work thoughtout this series of articles
                i will be providing a block of code, and then explaining it further, after the block is provided
                i will also be providing some comments on relitively ambigious lines of code
            </p>
            
            <p>Here's some basic code i made for printing, which we will be expanding upon after explanation: </p>

            <pre class="language-x86asm"><code>start:
    mov ax, 07C0h
    mov ds, ax

    mov si, title_string
    call print_string
    jmp $

print_string:
    mov ah, 0Eh ; bios number 0Eh, sets for teletype output function
print_char:
    lodsb ; loads byte at SI, into AL and increments SI

    cmp al, 0 ; 0 stored in al if at end of string
    je printing_finished

    int 10h ;bios interrupt 0x10, to print char stored in AL
    jmp print_char
printing_finished:
    ret

title_string db 'Welcome to the lytlnybl bootloader!',0

times 510-($-$$) db 0 ; pads the rest of the bootloader with 510 bytes, aiming for a 512 byte bootloader
dw 0xAA55 ; specifies the end of the bootloader, recognised by bios</code></pre>

            <h2 style="font-size: 20px;">The "start" section:</h2>
            <p>Just a warning, alot of things you might have to take my word for, as there 
                will things we need to do that cannot be explained in a couple of sentences, and would take 
                quite alot of explanation, but i will try to answer all things that i have tried to make you take my word 
                for in the more theory focused sections.
            </p>
            <p>
                Now, the first two lines of code (inside of the start section) are things that i cannot provide that much context on,
                due to them being entangled with a wide concept in x86 programming.
                But i will briefly explain here.
            </p>
            <pre><code>mov ax, 07C0h
mov ds, ax</code></pre>
            <p>
                With these two lines, the first line loads the value <span class="hljs">0x07C0</span> into the 
                ax register, this is the segment where the bootloader code is loaded by the bios, This
                is something when we will further cover when i go over x86 Segmentation, as that's a large 
                topic in x86.
            </p>
            <p>
                Just after that we set ds to the value in ax, this will set the ds register,
                which represents the data segment to the value of AX, ensuring that memory accesses within the bootloader
                use the correct segment, if we didn't include this line, later when we would try to print characters, we might notice
                that our code would just be printing a random ammount or no characters at all. This will be because it will be reading from 
                memory addresses not relative to the segment that the bootloader code is running in, this will also be covered in more detail in the next 
                segment of articles. (pun not intended)
            </p>
            <p>
                This just about wraps up the hardest part to understand of our printing program, and it's only hard to 
                understand because we don't have the required knowledge needed to comprehend our reasons for doing what 
                we are doing.
            </p>
            <p>
                Continuing with the start section, we then have our next couple of lines, these being:
            </p>
            <pre><code>mov si, title_string
call print_string
jmp $</code></pre>

            <p>
                <span class="hljs">mov si, title_string</span>, this first line is what tells us what string we need to print,
                as later on in the code we use <span class="hljs">db</span> (define byte) to store our string in memory, as seen here: 
                <span class="hljs">title_string db 'Welcome to the lytlnybl bootloader!',0</span> although, you might suspect, like in alot
                of programming languages, that we would just be passing the whole of the string to the <span class="hljs">si</span> register.
                but that is not what is happening, instead we are passing the memory location of the first character in the print_string
                this is because, like in C, strings are treated as arrays, which is evident with the null pointer which shows that we are at the end 
                of our string/list, when we pass the first memory location, we would then increment this and print char by char, when we go into 
                our printing sections.
            </p>

            <p>
                These next two lines: <span class="hljs">call print_string</span> and <span class="hljs">jmp $</span> are extremely simple,
                we first, call the memory location for print_string, this is done so we can return to this memory location after printing, the next line just jumps to itself
                over and over again, so it makes an infinite loop, which makes the BIOS hang until we stop the process
            </p>
            <h2 style="font-size: 20px;">The "print_string" section:</h2>
            <p>
                Let's just look at the whole of our print section and i can explain it all in the 
                coming paragraphs, so our print section goes as follows:
            </p>
            <pre><code>print_string:
    mov ah, 0Eh ; bios number 0Eh, sets for teletype output function
print_char:
    lodsb ; loads byte at SI, into AL and increments SI
            
    cmp al, 0 ; 0 stored in al if at end of string
    je printing_finished
            
    int 10h ;bios interrupt 0x10, to print char stored in AL
    jmp print_char
printing_finished:
    ret</code></pre>
            <p>
                The first line "<span class="hljs">mov ah, 0Eh</span>" moves the value '<span class="hljs">0Eh</span>' into the '<span class="hljs">ah</span>' register.
                In BIOS interrupt services '<span class="hljs">ah</span>' typically specifies the functin being requested. In this case,
                '<span class="hljs">0Eh</span>' is the function number for teletype output.
            </p>
            <p>
                Then we go into the 'print_char' section, this will be called over and over
                again until we print the end of our string
            </p>
            <p>
                The "<span class="hljs">lodsb</span>" instruction (as said in the comment) loads the byte at the memory
                adress pointed by the '<span class="hljs">si</span>' register (which in the beggining would be the first char) into the 
                "<span class="hljs">al</span>" register, and then increments the '<span class="hljs">si</span>' register to point to the next byte in memory
            </p>

            <p>
                Next we have "<span class="hljs">cmp al, 0</span>" and "<span class="hljs">je printing_finished</span>"
                the first instruction compares the value in '<span class="hljs">al</span>' register
                with the value '<span class="hljs">0</span>', checking if it's the null terminator, which marks the end of the string.
                After that we use '<span class="hljs">je</span>' (which means, jump if equal) instruction to jump to 'printing_finished'
                if the value in '<span class="hljs">si</span>' is the null terminator, which is 0.
            </p>

            <p>
                Then, simply, if we are not at the end of our string, we carry out our final
                instructions: "<span class="hljs">int 10h</span>" and "<span class="hljs">jmp print_char</span>".
                The first of the two does the interrupt service '<span class="hljs">10h</span>' which
                is the BIOS interrupt for video services and in this case, the value in '<span class="hljs">ah</span>'
                is '<span>0Eh</span>' indicating a teletype output, so the byte in '<span class="hljs">al</span>'
                is interpreted into a char using ASCII and is then printed to the screen.
            </p>

            <p>
                Then in our final section we return back to start to go into our infinite loop.
            </p>

            <h2 style="font-size: 20px;">Final Two lines</h2>
            <p>
                I'll now explain the last two lines, which may look a little confusing, these are:
            </p>
            <pre><code>times 510-($-$$) db 0
dw 0xAA55</code></pre>
            <p>
                The first line tells the assembler to add enough zeroes at the end of 
                the bootloader code to make it exactly 510 bytes long. This ensures that the 
                bootloader fills up most of the available space in the 512 byte sector reserved
                for the bootloader.
                Then, the next line marks teh end of the bootloader. It's like signing of the 
                bootloader with a specific code '<span class="hljs">0xAA55</span>' which tells the BIOS that 
                this is a valid boot sector. When the bios loads the bootloader, it checks for this signature
                to make sure it's a legitimate bootable sector before proceeding with the boot process.
            </p>

            <p>
                That wraps up our printing, which will be utilized a couple times in the BIOS,
                Although, i'm pretty sure when we move out of the bios, we will have to print in a different
                way, as we will not have access to the bios teletype services.
                Now, it's time to move onto our section which will load our kernel into memory.
            </p>

            <p>
                Before we move on, here is the makefile for our code:
            </p>

            <pre><code># Compiler
NASM := nasm

# Compiler flags
NASMFLAGS := -f bin

# Source files
SRC := print.asm

build: $(SRC)
    $(NASM) $(NASMFLAGS) -o print.o $(SRC)
    dd if=print.o of=print.img
    qemu-system-x86_64 -s print.img
    rm -f print.o

clean:
    rm -f *.o *.img</code></pre>

            <h2>Loading the kernel</h2>



        </div>
    </div>
    <script src="js/winbox.bundle.js"></script>
    <script src="js/blog.js"></script>
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js"></script>
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/languages/x86asm.min.js"></script>
</body>