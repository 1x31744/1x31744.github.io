<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kxxpa</title>
    <link rel="icon" type="image/png" href="images\K.png"/>
    <link rel="stylesheet" href="css/style.css">
    <link rel="preload" href="winbox.bundle.min.js" as="script">
    <link
    rel="stylesheet"
    href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/xt256.min.css"
    />
    <!-- qtcreator-dark -->
</head>
<body>
    <div class="topbar">
        <h1> Tyler Thompson </h1>
    </div>
    <div class="blog_window">
        <div id="blog_selector" class="blog_selector">
            <div class="blog_selector_title">
                FILES
            </div>
            <div style="margin: 35px;"></div>
            <div id="blog_files_content" class="blog_files_content">
                <button class="root_file" id="root_button">
                    <img src="folder.png" class="file_image">
                    <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Blog:/></p>
                </button>
                <div></div>
                <div id="second_column" class="column"> 
                    <button id="OS_file" class="seconditem">
                        <img src="folder.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">OS_Work:/></p>
                    </button>
                    <div id="os_column" class="column" style="display: none;">
                        <button id="os_part1_button" class="thirditem">
                            <img src="file.png" class="file_image">
                            <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Part I : Intro</p>
                        </button>
                        <button id="os_part2_button" class="thirditem">
                            <img src="file.png" class="file_image">
                            <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Part II : Bootloading</p>
                        </button>
                        <button id="os_part3_button" class="thirditem">
                            <img src="file.png" class="file_image">
                            <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Part III : Learning about x86</p>
                        </button>
                    </div>
                    <button id="nes_file" class="seconditem">
                        <img src="folder.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Making_An_NES_Emulator:/></p>
                    </button>
                    <div id="nes_column" class="column" style="display: none;">
                        <button id="nes_part1_button" class="thirditem">
                            <img src="file.png" class="file_image">
                            <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Part I : Intro</p>
                        </button>
                        <button id="nes_part2_button" class="thirditem">
                            <img src="file.png" class="file_image">
                            <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Part II : The Bus and 6502 :0</p>
                        </button>
                    </div>
                    <button id="raster_file" class="seconditem">
                        <img src="folder.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">CPU_Rasterisation:/> (coming soon)</p>
                    </button>
                    <button id="phys_file" class="seconditem">
                        <img src="folder.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Making_A_Rendering_And_Physics_Engine:/> (coming soon)</p>
                    </button>

                    <button id="gol_asm" class="seconditem">
                        <img src="folder.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Coding_Challenge:Bare_Metal_Game_Of_Life:/> (coming soon)</p>
                    </button>
                    <button id="school_proj_file" class="seconditem">
                        <img src="file.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">School_Project_For_Making_An_Interpreter.ty (coming soon)</p>
                    </button>
                    <a href="https://github.com/kxxpa">
                    <button href="https://www.w3schools.com" id="github_button" class="seconditem">
                        <img src="file.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Github.ty</p>
                    </button>
                    </a>
                    <button id="contact_button" class="seconditem">
                        <img src="file.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">Contact.ty</p>
                    </button>
                    <button id="about_button" class="seconditem">
                        <img src="file.png" class="file_image">
                        <p style="align-self: right; display: inline-block; transform: translate(0, -50%);">About.ty</p>
                    </button>
                </div>
            </div>
        </div>

        <div id="blog_viewer" class="blog_viewer">
            <div class="blog_selector_title">
                VIEWER
            </div>
            <div id="blog_content" class="blog_content" style="margin-top: 35px;">
                <h2>Use the files to view content within my blog</h2>
            </div>
        </div>
    </div>
    <div id="backstore" style="display: none;">
        <div id="about_content">
            <h2>about_me:#<span class="cursor"></span></h2>
            <p>My name is Tyler Thompson, I go online as Kxxpa, I have been programming for 5 years</p>
            <p>I am fluent in many programming languages, these include C++, Python, Rust. My favorite one is split between Rust and C++.</p>
            <p>Programming is what i mainly do in my freetime, I love it, I've made many projects that i've just done for fun.</p>
            <p>These include stuff like: A ray tracer, an abstract syntax tree programming language, a chip 8 interpreter, and i'm probably making more projects as you're reading this.</p>
        </div>
        <div id="contact_content" class="info_pages">
            <h2>contact_me:#<span class="cursor"></span></h2>
            <p>You can contact me for any reason whatsoever, if you want to collaborate on a project, work with me or just want to talk. Go ahead!</p>
            <p>You can send me an email over at koopahello@gmail.com</p>
        </div>
        <div id="os1_content">
            <h1 style="font-size: 40px;"><u>Making an OS using NASM and C</u></h1>
            <h1>Part I : Intro</h1>
            <h2>Preface</h2>
            <p>After looking at the os-dev wiki, I found many of the tutorials to be extremely confusing and aimless.
                and making my own operating system has always been a plan of mine. At the time of writing,
                I have very little knowledge on how to make bootloaders and kernels (which is probably why os-dev has been so confusing for me).
                And there are also very few resources online on how to make operating systems; they are either 1000-page university-level documents that
                Don’t start at boot loading and mainly focus on the theory behind processes and paging, many operating concepts that will take months of
                reading to get through, or are unfinished or small documents that do not provide enough info.</p>

            <p>Surprisingly, there are only a couple things online that are aimed at getting beginners started on operating system development.
                I aim to try and demystify the process of writing your own operating system in this blog without it taking up too much of your time.
                If there are any problems or things that confuse you in any of my articles, please email me about them, as I am eager to improve both my technical writing and programming.</p>

            <p>Although this series of articles is aimed at beginners, I recommend making sure you know a bit about how any flavor of assembly works.
                and how C works. That’s all the required knowledge you would need to get started.</p>

            <p>Another thing to say is that I intend to use my writing style to only give you the necessary points for understanding the code.
                behind a lot of the aspects behind OS development and not actually go into depth about all these types of topics, but I probably will write
                a few articles about the theory behind it all, as that is required to understand how BIOS and CPU architecture work, to start writing OS stuff.</p>

            <h2>Specifications</h2>

            <p>My operating system will work on x86 CPUs, will be stored on a virtual floppy disk, and will be made using C and ASM.
                There will also be some other tools being used in order to make the development process a lot easier. Such as GDB,
                to debug whatever I write, Makefiles in order to build the project fast, and qemu in order to run the OS without having to reboot my system repeatedly.</p>

            <h2>Getting started : What's first?</h2>

            <p>The first step in making an operating system is to either set up or make a bootloader.
                I will be making one; if you wanted to set one up, you could probably set up the kernel you write with GRUB.
                In order to make a bootloader, there will only be 3 steps.</p>

            <p>Step 1: printing in bios that we are booting the OS.</p>
            <p>Step 2: reading the hard disk in the right place and loading the kernel into memory (in bios).</p>
            <p>Step 3: giving access to the kernel, by jumping to where we loaded the kernel into memory (still in bios).</p>

            <p>We also need to remember that we are programming assembly without an operating system.
                This means that we can’t use any OS interrupts in order to print to the screen, read from certain file locations,
                or anything else we would have taken for granted when doing our regular programming.</p>

            <p>This is a good decomposition of the problem of writing our own bootloader; even now, you could even stop reading.
                and google how to do these steps or even ask ChatGPT, it’s good to decompose problems for a massive subject like making your own OS,
                It can help us learn about the aspects rather than being overwhelmed with information when we google “how to make a bootloader."
                We can google “how to print to bios in NASM” and “how to read from a hard disc in bios NASM.”.</p>

            <p>Even printing is complex without an operating system, so don’t get hung up if you take an hour trying to do any aspect of what
                we’re doing, especially if you’re just sitting there trying to understand some instructions or code (I have done this many times).</p>

            <p>In the next chapter, I will cover and go step by step with you on how to produce the bootloader using the steps I have laid out.</p>
        </div>
        <div id="os2_content">
            <h1>Part II : Bootloading</h1>
            <h2>A few words...</h2>
            <p>
                If you love coding, you're probably eager to get straight into the programming and make something that functions. 
                Well, good news! In this chapter, we will end with a fully functioning bootloader that loads into a simple kernel that just loads a hello-world message. 
                How exciting!
            </p>
            
            <p>
                This also shouldn't take that many lines of code, although the instructions can be very complex, which I will try to explain to the best of my ability in this chapter.
            </p>

            <p>
                Sadly, if you like hands-on experience, the next chapter will cover a lot of theory, but I will try to make it as concise and quick as possible, 
                as I only try to cover key points that you can research later if you have any interest.
            </p>

            <h2>Printing in BIOS</h2>

            <p>
                Mainly, to demonstrate how things work through this series of articles, I will be providing a block of code and then explaining it further. 
                After the block is provided, I will also be providing some comments on relatively ambigious lines of code.
            </p>
            
            <p>
                Here's some basic code I made for printing, which we will be expanding upon after an explanation, to implement stuff like reading from storage and loading into memory:
            </p>

            <pre class="language-x86asm"><code>start:
    mov ax, 07C0h
    mov ds, ax

    mov si, title_string
    call print_string
    jmp $

print_string:
    mov ah, 0Eh ; bios number 0Eh, sets for teletype output function
print_char:
    lodsb ; loads byte at SI, into AL and increments SI

    cmp al, 0 ; 0 stored in al if at end of string
    je printing_finished

    int 10h ;bios interrupt 0x10, to print char stored in AL
    jmp print_char
printing_finished:
    ret

title_string db 'Welcome to the lytlnybl bootloader!',0

times 510-($-$$) db 0 ; pads the rest of the bootloader with 510 bytes, aiming for a 512 byte bootloader
dw 0xAA55 ; specifies the end of the bootloader, recognised by bios</code></pre>

            <h2 style="font-size: 20px;">The "start" section:</h2>
            <p>
                Just a warning: there are a lot of things you might have to take my word for, 
                as there will be things we need to do that cannot be explained in a couple of sentences and would take quite a lot of explanation, 
                but I will try to answer all the things that I have tried to make you take my word for in the more theory-focused sections.
            </p>
            <p>
                Now, the first two lines of code (inside of the start section) are things that I cannot provide that much context on due to 
                their being entangled with a wide concept in x86 programming. But I will briefly explain here.
            </p>
            <pre><code>mov ax, 07C0h
mov ds, ax</code></pre>
            <p>
                With these two lines, the first line loads the value <span class="hljs">0x07C0</span> into the ax register; 
                this is the segment where the bootloader code is loaded by the bios. This is something we will further cover when we go over x86 segmentation, 
                as that's a large topic in x86.
            </p>
            <p>
                Just after that, we set ds to the value in ax, This will set the ds register, which represents the data segment, 
                to the value of ax, ensuring that memory accesses within the bootloader use the correct segment. If we didn't include this line, 
                later, when we would try to print characters, we might notice that our code would just be printing a random amount or no characters at all. 
                This will be because it will be reading from memory addresses not relative to the segment that the bootloader code is running in; 
                this will also be covered in more detail in the next segment of articles. (pun not intended)
            </p>
            <p>
                This just about wraps up the hardest part to understand of our printing program, 
                and it's only hard to understand because we don't have the required knowledge 
                needed to comprehend our reasons for doing what we are doing.
            </p>
            <p>
                Continuing with the start section, we then have our next couple of lines, these being:
            </p>
            <pre><code>mov si, title_string
call print_string
jmp $</code></pre>

            <p>
                <span class="hljs">mov si, title_string</span>, this first line is what tells us what string we need to print,
                Later on in the code, we use <span class="hljs">db</span> (define byte) to store our string in memory, as seen here:
                <span class="hljs"> title_string db 'Welcome to the lytlnybl bootloader!', 0</span> although you might suspect, like in a lot
                of programming languages, that we would just be passing the whole of the string to the <span class="hljs">si</span> register.
                But that is not what is happening; instead, we are passing the memory location of the first character in the print_string.
                This is because, like in C, strings are treated as arrays, which is evident with the null pointer, which shows that we are at the end.
                of our string, when we pass the first memory location, we would then increment this and print char by char when we go into
                our printing sections.
            </p>

            <p>
                These next two lines: <span class="hljs">call print_string</span> and <span class="hljs">jmp $</span> are extremely simple,
                We first call the memory location for print_string. This is done so we can return to this memory location after printing, and the next line just jumps to itself.
                over and over again, so it makes an infinite loop, which makes the BIOS hang until we stop the process.
            </p>
            <h2 style="font-size: 20px;">The "print_string" section:</h2>
            <p>
                Let's just look at the whole of our print section, and I can explain it all in the
                coming paragraphs, so our print section goes as follows:
            </p>
            <pre><code>print_string:
    mov ah, 0Eh ; bios number 0Eh, sets for teletype output function
print_char:
    lodsb ; loads byte at SI, into AL and increments SI
            
    cmp al, 0 ; 0 stored in al if at end of string
    je printing_finished
            
    int 10h ;bios interrupt 0x10, to print char stored in AL
    jmp print_char
printing_finished:
    ret</code></pre>
            <p>
                The first line "<span class="hljs">mov ah, 0Eh</span>" moves the value '<span class="hljs">0Eh</span>' into the '<span class="hljs">ah</span>' register.
                In BIOS interrupt services, '<span class="hljs">ah</span>' typically specifies the function being requested. In this case,
                '<span class="hljs">0Eh</span>' is the function number for teletype output.
            </p>
            <p>
                Then we go into the 'print_char' section; this will be called over and over.
                again until we print the end of our string
            </p>
            <p>
                The "<span class="hljs">lodsb</span>" instruction (as said in the comment) loads the byte into memory.
                address pointed by the '<span class="hljs">si</span>' register (which in the beginning would be the first character) into the
                "<span class="hljs">al</span>" register, and then increments the '<span class="hljs">si</span>' register to point to the next byte in memory.
            </p>

            <p>
                Next we have "<span class="hljs">cmp al, 0</span>" and "<span class="hljs">je printing_finished</span>"
                The first instruction compares the value in the '<span class="hljs">al</span>' register.
                with the value '<span class="hljs">0</span>', checking if it's the null terminator, which marks the end of the string.
                After that, we use '<span class="hljs">je</span>' (which means jump if equal) instruction to jump to 'printing_finished'
                if the value in '<span class="hljs">si</span>' is the null terminator, which is 0.
            </p>

            <p>
                Then, simply, if we are not at the end of our string, we carry out our final
                instructions: "<span class="hljs">int 10h</span>" and "<span class="hljs">jmp print_char</span>".
                The first of the two does the interrupt service '<span class="hljs">10h</span>' which
                is the BIOS interrupt for video services, and in this case, the value in '<span class="hljs">ah</span>'
                is '<span>0Eh</span>' indicating a teletype output, so the byte in '<span class="hljs">al</span>'
                is interpreted into a character using ASCII and is then printed to the screen.
            </p>

            <p>
                Then, in our final section, we return to the beginning to go into our infinite loop.
            </p>

            <h2 style="font-size: 20px;">Final Two lines</h2>
            <p>
                I'll now explain the last two lines, which may look a little confusing. These are:
            </p>
            <pre><code>times 510-($-$$) db 0
dw 0xAA55</code></pre>
            <p>
                The first line tells the assembler to add enough zeroes at the end of
                the bootloader code to make it exactly 510 bytes long. This ensures that the
                Bootloader fills up most of the available space in the 512-byte sector reserved.
                for the bootloader.
                Then, the next line marks the end of the bootloader. It's like the signing of the
                bootloader with a specific code: '<span class="hljs">0xAA55</span>' which tells the BIOS that
                This is a valid boot sector. When the BIOS loads the bootloader, it checks for this signature.
                to make sure it's a legitimate bootable sector before proceeding with the boot process.
            </p>

            <p>
                That wraps up our printing, which will be utilised a couple times in the BIOS.
                Although I'm pretty sure when we move out of the bios, we will have to print in a different
                way, as we will not have access to the bios teletype services.
                Now, it's time to move onto our section, which will load our kernel into memory.
            </p>

            <p>
                Before we move on, here is the makefile for our code:
            </p>

            <pre><code># Compiler
NASM := nasm

# Compiler flags
NASMFLAGS := -f bin

# Source files
SRC := print.asm

build: $(SRC)
    $(NASM) $(NASMFLAGS) -o print.o $(SRC)
    dd if=print.o of=print.img
    qemu-system-x86_64 -s print.img
    rm -f print.o

clean:
    rm -f *.o *.img</code></pre>

            <h2>Loading the kernel</h2>

            <p>In order to load the kernel, we actually need a kernel to load. Here's a simple one:</p>

            <code><pre>start:
    mov ax, cs
    mov ds, ax

    mov si, hello_string
    call print_string

    jmp $

print_string:
    mov ah, 0Eh

print_char:
    lodsb

    cmp al, 0
    je done
    
    int 10h

    jmp print_char

done:
    ret

    hello_string db 'Hello World!, i am lytlnyblOS', 0</pre></code>

    <p>
        This code is extremely similar to the printing code we wrote earlier, with the only real difference being how x86 segmentation
        is handled in the first line of code; instead of loading the segment of the bootloader into the data segment register, we instead
        Take the code segment and load it into the data segment, so the data segment is in the same place as the code segment.
        is.
    </p>

    <p>
        Easy enough after focusing that much on printing earlier. Now let's modify the bootloader to accommodate loading.
        our new kernel, and I will then explain the need for the updated lines:
    </p>
    <pre><code>start:
    mov ax, 07C0h
    mov ds, ax

    mov si, title_string
    call print_string

    mov si, message_string
    call print_string

    call load_kernel_from_disk
    jmp 0900h:0000 ; gives control to the kernel by jumping to it's starting point.

load_kernel_from_disk:
    mov ax, 0900h
    mov es, ax
    
    mov ah, 02h ; service number, 
    mov al, 01h ; number of sectors we want to read from (only simple kernel for now, so less than 512 bytes)
    
    mov ch, 0h ; number of track we would like to read from, is just 0.
    mov cl, 02h ; sector number that we would like to read its content, this is the second sector

    mov dh, 0h ; the type of disk we would like to read from, 0h means we are reading from a floppy disk. 
    mov dl, 80h ; this is the hard disk we are reading from, 80h means hard disk #0, 81h would be hard disk #1

    mov bx, 0h ; memory adress that content will be loaded into
    int 13h ; 13h provides services related to hard disk

    ; if successful, carry flag will be set to 0, otherwise carry flag is 1
    jc kernel_load_error

    ret

kernel_load_error:
    mov si, load_error_string
    call print_string

    jmp $

print_string:
    mov ah, 0Eh ; bios number 0Eh, sets for teletype output function
print_char:
    lodsb ; loads byte at SI, into AL and increments SI

    cmp al, 0 ; 0 stored in al if at end of string
    je printing_finished

    int 10h ;bios interrupt 0x10, to print char stored in AL

    jmp print_char
printing_finished:
    ;print new line
    mov al, 10d ; ASCII code for new line
    int 10h 

    ;read current cursor position
    mov ah, 03h ; function to read cursor position
    mov bh, 0 ; page number 0 for default page
    int 10h ; 10h now used to read cursor position

    ;move cursor to beggining
    mov ah, 02h ; function to set cursor position
    mov dl, 0 ; column number (0 for begginign of line)
    int 10h ; 0x10 to set cursor pos

    ret

title_string db 'Welcome to the lytlnybl bootloader!',0
message_string db 'Loading up the kernel for you...',0
load_error_string db 'Oh oh!, there was a problem loading the kernel',0

times 510-($-$$) db 0 ; pads the rest of the bootloader with 510 bytes, aiming for a 512 byte bootloader
dw 0xAA55 ; specifies the end of the bootloader, recognised by bios</code></pre>

    <p>
        There's not that much that is new, but this is where most of the code is that I can only explain on a surface level.
        But I will explain it all as best as I can now in order of logical operation, and then in later chapters we can cover these x86 concepts.
        in the next chapter of this series.
    </p>

    <h2 style="font-size: 20px;">The "load_kernel_from_disk" section:</h2>

    <p>
        Carrying on in order of logical operation, after we print two times (for loading and intro messages), we go straight
        into our section for loading the kernel from disc, and the only goal of this is to take the kernel from the device's storage.
        and loading it into memory.
    </p>
    <p>
        To start doing this, we first set up the segment address, which is '<span class="hljs">0900h</span>' which is loaded into
        the '<span class="hljs">ax</span>' register, then copied to the es register; this segment address is where the kernel will be loaded.
        into memory.
    </p>
    <p>
        Next, with lines "<span class="hljs">mov ah, 02h</span>" and "<span class="hljs">mov al, 01h</span>" we are setting up our
        disc read parameters, the '<span class="hljs">ah</span>' register is set to 02h, indicating the BIOS read functionality.
        Then, the '<span class="hljs">al</span>' register is set to 01h, indicating that only one sector will be read from (our kernel is small).
        so it only takes up one sector.
    </p>
    <p>
        The next lines, "<span class="hljs">mov ch, 02h</span>" and "<span class="hljs">mov cl, 02h</span>" require knowledge about
        discs rather than segmentation, in the first line, '<span class="hljs">ah</span>' gets 0h loaded into it (which is just 0).
        This is the cylinder we want to read from; this would just be the 0th cylinder, as our program is not big enough to be stored.
        on multiple cylinders. The '<span class="hljs">al</span>' register stores the segment number we want to read from; this is
        the reason our virtual machine would use a floppy disk, as the segments in a floppy disk are 512 bytes, which is the size
        of our bootloader, so we can easily just read from the second sector on the disk.
    </p>
    <p>
        Then next, we specify the disc we are reading from with the lines: "<span class="hljs">mov dh, 0h</span>" and
        "<span class="hljs">mov dl, 80h</span>" The first instruction defines the type of disc that we are going to move from.
        '<span class="hljs">0h</span>' signifies that we are reading from a floppy disk. The next line is simply the number of discs we are reading from:
        '<span class="hljs">80h</span>' signifies that we are reading from disc 0, and 81h would be disc 1.
    </p>

    <p>
        Then "<span class="hljs">mov bx, 0h</span>" just signifies the offset of the  segment we will load into, which will just be 0
        as we want to load it into the start of our segment.
    </p>
    <p>
        Our final line for reading is just "<span class="hljs">int 13h</span>" which is an instruction that calls
        the BIOS interrupt, which performs the disc read operation based on the provided parameters.
    </p>

    <p>
        Then the only thing left to do is check for errors; the interrupt earlier would set the carry flag if there was an error.
        So we can just use jc (jump if carry) to jump to an error handling sub-routine, which will just output a message signifying
        an error and then create an infinite loop.
    </p>

    <p>
        That's all on reading from the disc; let's now look at the changes that were made to printing, which only really
        Just allow us to print multiple lines.
    </p>
    
    <h2 style="font-size: 20px;">Printing Changes:</h2>

    <p>
        The only real changes to printing made in our code are the changes to the printing_finished section of our code, as
        seen here:
    </p>

    <pre><code>printing_finished:
    ;print new line
    mov al, 10d ; ASCII code for new line
    int 10h 

    ;read current cursor position
    mov ah, 03h ; function to read cursor position
    mov bh, 0 ; page number 0 for default page
    int 10h ; 10h now used to read cursor position

    ;move cursor to beggining
    mov ah, 02h ; function to set cursor position
    mov dl, 0 ; column number (0 for begginign of line)
    int 10h ; 0x10 to set cursor pos

    ret</code></pre>

    <p>
        All this code is pretty basic; in the first block, our goal is to make a new line, and our comments explain that pretty well enough
        What we do next is read the current cursor position; this is ultimately not needed, but we can do conditions for this to print error messages if
        the cursor row is in the incorrect place, dh will store the row number, so we can jump to an error message if it is not in the correct row.
        The final block is to move the cursor to the beginning of the current row after making a new line, which is also explained in the comments for the code.
    </p>

    <p>
        There we have it. After writing all this, you can say you've made your own operating system (albeit a very simple one).
        But it's a bootloader that loads a kernel, which then outputs a message, which may seem pretty dull, but just consider the fact that
        that this was all done on bare metal hardware without an OS to support us, which is pretty cool.
    </p>

    <p>
        Here is the makefile for the kernel and bootloader:
    </p>
    <pre><code>BOOT_FILE = bootloader/bootloader.asm 
KERNEL_FILE = kernel/basic_kernel.asm 
        
build: $(BOOT_FILE) $(KERNEL_FILE)
    nasm -f bin $(BOOT_FILE) -o bootstrap.o
    nasm -f bin $(KERNEL_FILE) -o kernel.o
    dd if=bootstrap.o of=kernel.img
    dd seek=1 conv=sync if=kernel.o of=kernel.img bs=512
    qemu-system-x86_64 -s kernel.img
            
clean:
    rm -f *.o</code></pre>
        </div>
        <div id="os3_content">
            <h1>Part III : Learning about x86</h1>
            <h2>The theory being covered</h2>
            <p>
                There are only really four things we need to learn about before continuing to make our bootloader
                And these are: 
            </p>
            <ul>
                <li>x86 Operating Modes</li>
                <li>x86 Memory Segmentation (not to be confused with segmentation in disk drives)</li>
                <li>The x86 Run-time Stack</li>
                <li>x86 Interrupts</li>
            </ul>

            <p>So let's start, tackling these in order.</p>

            <h2>x86 Operating Modes</h2>

            <p>
                There are two modes we will be working with in x86, these are 16-bit real 
                mode and 32-bit protected mode, but what exactly is an operating mode?
                An operating mode? An operating mode refers to a specific configuration in 
                which the CPU operates, each mode defines how the CPU interacts with memory, hardware 
                and software, they each other many different features, capabilities, and limitations.
            </p>

            <p>
                To be expected, protected and real mode are not the only modes in
                x86, there is long mode (which only exists in 64 bit systems), compatibility mode (which is 16 bit)
                and many others.
                But as we are writing a 32-bit x86 operating system our only goal is to get into 
                protected mode which is mainly used for modern operating sytems and software, which is what we are making.
                When we started writing our OS in the last chapter, we were working in 
                real mode, as real mode is the initial operating mode of x86 processors during 
                system boot-up.
            </p>

            <p>Here is everything about real mode:</p>

            <ul>
                <li>
                    Real mode is a minimalist environment, unsuprisingly
                    providing only the essential features required to bootstrap a computer 
                    system. It lacks many advanced features that we will need to access in protected mode, 
                    Such as memory protection
                </li>

                <li>
                    Real mode also has direct access to resources without 
                    abstraction layers or OS intervention. Which allows for low 
                    level manipulation of hardware components.
                    It also allows access of BIOS interrupts, which (like we used before)
                    are commonly used during system boot-up and for low-level system 
                    programming tasks perfomed in real mode. BIOS interupts provide a way for software 
                    to interact witht the system BIOS.
                </li>

                <li>
                    Now, onto limitations, the most important is probably a lack 
                    of memory protection (which if you like cybersecurity you'd be
                    interested in), real mode offers absolutely no memory protection 
                    mechanisms, leaving the system utterly vulnerable to memory corruption and 
                    unauthorized access. Software running in real mod can freely access and modify 
                    any memory location, leading to security and stability issues.
                </li>
            </ul>

            <p>And now, let's talk about some Protected Mode:</p>

            <ul>
                <li>
                    The advantages for protected mode are really just the disadvantages of Real mode.
                    It has Memory Protection, Multitasking support, privilege levels, among other things.
                </li>

                <li>
                    However, protected mode provides additional complexity compared to the 
                    real mode due to its advanced features mentioned before.
                </li>
            </ul>

            <p>
                That just about sums up what we need to know about our x86 operating modes, 
                as a summary, we are currently in real mode and need to get into our protected mode to get 
                many useful features for making our own OS.
            </p>

            <h2>x86 Memory Segmentation</h2>

            <p>
                What is memory? Well, physically we can think of memory as just 
                an array of bytes, each having a memory address that is just a numerical value 
                stored in base 16, this is our physical view of memory, however we need a logical 
                view of memory that can make alot of things much easier. This is where memory segmentation comes in.
            </p>

            <p>
                Memory segmentation in x86 architecture is a feature that 
                divides the memory into segments to allow for more flexible
                memory management and protection. Understanding it is extremely 
                important when developing an operating system for x86 platforms as in 
                real mode, memory segmentation is the default and primary mechanism for 
                adressing memory. In protected mode, memory segmentation is still the default 
                memory adressing scheeme, but it can be configured or optimied to work alongside or be 
                bypassed in favour of other memory management meothds like paging 
            </p>

            <p>
                Memory segmentation isn't really used in the modern day, it's an old way of formulating memory,
                it's used on x86 becuase of physical design factors of the CPU. Paging mostly is, which we will
                likely use in our operating system, we will get into that later.
            </p>

            <p>
                Memory segmentation works differently in real mode and protected mode 
                so let's look at them individually, starting with a basic overview and then 
                looking at how it's done in real mode.
            </p>

            <h2 style="font-size: 20px;">How does memory segmentation? An overview.</h2>

            <p>
                First, let's look at a basic overview of how memory segmentation works,
                Segmentation is where main memory is seperated into parts called segments where 
                each segments stores related data. To access data inside a segment, each byte is 
                reffered to by it's own offset.
                A running program is split into 3 different segments in x86, these are:
            </p>
            <ul>
                <li>
                    Code segment: Stores code of the program under execution
                </li>
                <li>
                    Data segment: Stores the data of the program
                </li>
                <li>
                    Stack segment: Stores the data of the program's stack
                </li>
            </ul>

            <h2 style="font-size: 20px;">How does memory segmentation work in real mode?</h2>

            <p>
                We will start with real mode just so we can be clear without having to cover all of the extra stuff you 
                have to consider in protected mode (like global descriptor tables). Here in real mode segmentation is mapped
                by the view of the processor itself, so as said before, there is no way to avoid it.
                It is also worth mentioning that each segment in real mode is 64KB in size.
                In real mode, we have segment registers with each register having a size of 16 bits, these registers are:
                <ul>
                    <li>
                        CS: used to define a code segment
                    </li>
                    <li>
                        SS: used to define a stack segment
                    </li>
                    <li>
                        DS: used to define a data segment
                    </li>
                </ul>
                <p>There are also a few other registers that we can use:</p>
                <ul>
                    <li>
                        ES: additional segment register that provides flexibility in memory access,
                        usually used when you need to access more segments without changing the value of ds
                    </li>
                    <li>
                        GS: global segment register, made to provide a segment for global data but can be used 
                        similarly to ES
                    </li>
                    <li>
                        FS: file segment register, made to access local thread storage but can also be used similarly to ES
                    </li>
                </ul>
                <p>Each segment stores the starting memory adress of a segment. We can reach any byte in a segment by setting the offset between 0-64kb</p>
            </p>

            <p>Let's look at an example for memory segmentation.</p>

            <p>
                Assume we have some code for a program loaded into memory, which is stored at 100d. To reach the first byte of 
                this code we use the offset 0, and increase it for any next byte we want to access.
                We would also set the cs register to 100d as that is the starting adress for the current code segment we are 
                trying to run.
            </p>

            <p>
                x86 always runs with memory segmentation in mind, so when we use the jmp instruction, we aren't jumping to a 
                specific space in memory, so let's say we write jmp 100d, we are actually jumping to the offset of 100d inside the 
                current code segment. This also happens internally with the PC (program counter), where the PC doesn't
                store the full memory adress, just the offset of the next instruciton.
                Any jump to a location in the same code segment is called a near jump/call, otherwise it is called a far jump/call.
                To do far jumps, you can do stuff like "<span class="hljs">jmp 900:1d</span>", this will load 900d into the 
                CS and 1d into the PC. 
            </p>

            <p>
                This is exactly the same for the other two segments (data and stack), it was just easy to demonstrate using the CS 
                and jump/call because the functionality is related to code which is easy to manipulate code flow.
                An example for DS would be lodsb, and for SS, the push instruction.
            </p>

            <h2 style="font-size: 20px;">How was memory segmentation used in the bootloader?</h2>

            <p>
                Previously, when we wrote the bootloader (and the basic kernel) we dealt with segments, let's look at our code again 
                and i can now explain it now that you know everything you need to know about memory segmentation in real mode.
            </p>

            <p>
                The first thing we will look at goes all the way back to when we wrote our printing code together, this 
                is in the start label, here:
            </p>

            <pre><code>mov ax, 07C0h
mov ds, ax</code></pre>

            <p>
                It's worth noting that the CS register is already set to <span class="hljs">07C0h</span> by the bootloader
                but we also set the same value to the DS register, This ensures the bootloader can correctly access it's own code and data
                correclty.
                But you might ask: "why do we need to load the location into ax and then ds". This is because we can't directly load 
                into segment registers due to multiple limitations on the instruction set, so we just use ax as an intermediary register in order 
                to load into ds.
            </p>

            <p>Moving on, the next place we used memory segmentation</p>

            <p>
                This is when we were trying to load the kernel into memory from the bootloader, More specifically it was when 
                we were trying to use the 13:02h interrupt, which is the interrupt for taking code from storage into memory.
                Which can all be seen in this code here: 
            </p>

            <pre><code>load_kernel_from_disk:
mov ax, 0900h
mov es, ax

mov ah, 02h ; service number, 
mov al, 01h ; number of sectors we want to read from (only simple kernel for now, so less than 512 bytes)

mov ch, 0h ; number of track we would like to read from, is just 0.
mov cl, 02h ; sector number that we would like to read its content, this is the second sector

mov dh, 0h ; the type of disk we would like to read from, 0h means we are reading from a floppy disk. 
mov dl, 80h ; this is the hard disk we are reading from, 80h means hard disk #0, 81h would be hard disk #1

mov bx, 0h ; memory adress that content will be loaded into
int 13h ; 13h provides services related to hard disk</code></pre>

            <p>
                Here, what we do first is store 0900h into the extra segment register, as this is where we will be storing 
                the kernel in memory, you see, the interrupt 13h:02h loads the content (which we have defined with 
                prior registers) into the memory adress es:bx (where bx is the offset).
            </p>

            <p>
                Then after we do that we can commit a far jump to the next memory segment where the kernel will be stored.
                It's worth noting that a far jump changes the value of the cs register to wherever you jump to, in this case, it 
                will be set to 0900h, which is good because that's where the start of code segment for our kernel is.
                Then, in our kernel, we can set the ds register to the same as the cs in order to read code and data from the 
                same segment.
            </p>


            <h2 style="font-size: 20px;">How does memory segmentation work in protected mode?</h2>

            <p>
                So we have got down how memory segmentation works in real mode, and even know how it's used in our bootloader,
                that's pretty good, now we've just gotta cover protected mode and we're done with memory segmentation and can move 
                onto the run time stack
            </p>



        </div>

        <div id="nes1_content">
            <h1 style="font-size: 40px;"><u>Making an NES emulator (diary).</u></h1>
            <h1>Part I : Intro</h1>
            <h2>Preface</h2>
            <p>
                Just to note, this series will be structured like a diary, you could potentially use this for your own learning if you are also trying to make any type of emulator,
                but i will not try to go to extreme levels of detail in order to help you understand, this is mainly just to record my own learning and code of making an NES emulator, if 
                you want something to help you learn NES emulation, i reccoment a series by one lone coder on youtube. (which is also a recource i will be using)
            </p>
            <p>
                I hope you have fun reading my diary, thanks!
            </p>
        </div>
        <div id="nes2_content">
            <h1>Part II : The Bus and 6502 :0</h1>
            <h2>Day 1 : 3/4/2024 : 8:00PM</h2>
            <h2 style="font-size: 20px;">Setting up the bus:</h2>
            <p> 
                As the first step i'm doing is making the CPU, i will start with producing a bus for the CPU to read and send data from, the bus will also be sending data to an fake
                representation of RAM.
            </p>
            <p>
                Here's my setup for my Bus:
            </p>
            <pre><u>Bus.hpp</u><code>#pragma once
#include [<]cstdint>
#include "cpu6502.hpp"
#include [<]array>

class Bus {
public:
    Bus(); //constructor
    ~Bus(); //destructor
    
public: //devices
    cpu6502 cpu;
    //Fake ram
    std::array<uint8_t, 64 * 1024> ram;

public: //bus read and write
    void write(uint16_t addr, uint8_t data);
    uint8_t read(uint16_t addr, bool busReadOnly = false);
};
            </code></pre>
            <pre><u>Bus.cpp</u><code>#include "Bus.hpp"

Bus::Bus() {
    for (uint8_t &i : ram) i = 0x00;
}
Bus::~Bus() {

}

void Bus::write(uint16_t addr, uint8_t data) {
    if (addr >= 0x0000 && addr <= 0xFFFF) ram[addr] = data;
}

uint8_t Bus::read(uint16_t addr, bool busReadOnly) {
    if (addr >= 0x0000 && addr <= 0xFFFF) return ram[addr];
    return 0x00;
}
            </code></pre>

            
        </div>
    </div>
    <script src="js/winbox.bundle.js"></script>
    <script src="js/blog.js"></script>
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js"></script>
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/languages/x86asm.min.js"></script>
</body>