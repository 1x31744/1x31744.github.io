<h1>Part III : Learning about x86</h1>
<h2>The theory being covered</h2>
<p>
    There are only really four things we need to learn about before continuing to make our bootloader
    And these are: 
</p>
<ul>
    <li>x86 Operating Modes</li>
    <li>x86 Memory Segmentation (not to be confused with segmentation in disk drives)</li>
    <li>The x86 Run-time Stack</li>
    <li>x86 Interrupts</li>
</ul>
<p>So let's start, tackling these in order.</p>
<h2>x86 Operating Modes</h2>
<p>
    There are two modes we will be working with in x86, these are 16-bit real 
    mode and 32-bit protected mode, but what exactly is an operating mode?
    An operating mode refers to a specific configuration in 
    which the CPU operates, each mode defines how the CPU interacts with memory, hardware 
    and software, they each offer many different features, capabilities, and limitations.
</p>
<p>
    To be expected, protected and real mode are not the only modes in
    x86, there is long mode (which only exists in 64 bit systems), compatibility mode (which is 16 bit)
    and many others.
    But as we are writing a 32-bit x86 operating system our only goal is to get into 
    protected mode which is mainly used for modern operating systems and software, which is what we are making.
    When we started writing our OS in the last chapter, we were working in 
    real mode, as real mode is the initial operating mode of x86 processors during 
    system boot-up.
</p>
<p>Here is everything about real mode:</p>
<ul>
    <li>
        Real mode is a minimalist environment, unsuprisingly
        providing only the essential features required to bootstrap a computer 
        system. It lacks many advanced features that we will need to access in protected mode, 
        Such as memory protection
    </li>
    <li>
        Real mode also has direct access to resources without 
        abstraction layers or OS intervention. Which allows for low 
        level manipulation of hardware components.
        It also allows access of BIOS interrupts, which (like we used before)
        are commonly used during system boot-up and for low-level system 
        programming tasks performed in real mode. BIOS interrupts provide a way for software 
        to interact with the system BIOS.
    </li>
    <li>
        Now, onto limitations, the most important is probably a lack 
        of memory protection (which, if you like cybersecurity, you'd be
        interested in), real mode offers absolutely no memory protection 
        mechanisms, leaving the system utterly vulnerable to memory corruption and 
        unauthorized access. Software running in real mode can freely access and modify 
        any memory location, leading to security and stability issues.
    </li>
</ul>
<p>And now, let's talk about Protected Mode:</p>
<ul>
    <li>
        The advantages for protected mode are really just the disadvantages of Real mode.
        It has Memory Protection, Multitasking support, privilege levels, among other things.
    </li>
    <li>
        However, protected mode provides additional complexity compared to
        real mode due to its advanced features mentioned before.
    </li>
</ul>
<p>
    That just about sums up what we need to know about our x86 operating modes, 
    as a summary, we are currently in real mode and need to get into our protected mode to get 
    many useful features for making our own OS.
</p>
<h2>x86 Memory Segmentation</h2>
<p>
    What is memory? Well, physically we can think of memory as just 
    an array of bytes, each having a memory address that is just a numerical value 
    stored in base 16, this is our physical view of memory, however we need a logical 
    view of memory that can make alot of things much easier. This is where memory segmentation comes in.
</p>
<p>
    Memory segmentation in x86 architecture is a feature that 
    divides the memory into segments to allow for more flexible
    memory management and protection. Understanding it is extremely 
    important when developing an operating system for x86 platforms as in 
    real mode, memory segmentation is the default and primary mechanism for 
    adressing memory. In protected mode, memory segmentation is still the default 
    memory adressing scheme, but it can be configured or optimised to work alongside or be 
    bypassed in favour of other memory management methods like paging.
</p>
<p>
    Memory segmentation isn't really used in the modern day; it's an old way of formulating memory and
    is used on x86 because of physical design factors of the CPU. Whereas paging mostly is, which we will
    likely use in our operating system, we will get into that much later.
</p>
<p>
    Memory segmentation works differently in real mode and protected mode 
    so let's look at them individually, starting with a basic overview and then 
    looking at how it's done in real mode.
</p>
<h2 style="font-size: 20px;">How does memory segmentation work? An overview.</h2>
<p>
    First, let's look at a basic overview of how memory segmentation works,
    Segmentation is where main memory is seperated into parts called segments where 
    each segment stores related data. To access data inside a segment, each byte is 
    referred to by it's own offset.
    A running program is split into 3 different segments in x86, these are:
</p>
<ul>
    <li>
        Code segment: Stores code of the program under execution
    </li>
    <li>
        Data segment: Stores the data of the program
    </li>
    <li>
        Stack segment: Stores the data of the program's stack
    </li>
</ul>
<h2 style="font-size: 20px;">How does memory segmentation work in real mode?</h2>
<p>
    We will start with real mode just so we can be clear without having to cover all of the extra stuff you 
    have to consider in protected mode (like global descriptor tables). Here in real mode, segmentation is mapped
    by the view of the processor itself, so as said before, there is no way to avoid it.
    It is also worth mentioning that each segment in real mode is 64KB in size.
    In real mode, we have segment registers with each register having a size of 16 bits, these registers are:
    <ul>
        <li>
            CS: used to define a code segment
        </li>
        <li>
            SS: used to define a stack segment
        </li>
        <li>
            DS: used to define a data segment
        </li>
    </ul>
    <p>There are also a few other registers that we can use:</p>
    <ul>
        <li>
            ES: additional segment register that provides flexibility in memory access,
            usually used when you need to access more segments without changing the value of ds
        </li>
        <li>
            GS: global segment register, made to provide a segment for global data but can be used 
            similarly to ES
        </li>
        <li>
            FS: file segment register, made to access local thread storage but can also be used similarly to ES
        </li>
    </ul>
    <p>Each segment stores the starting memory address of a segment. We can reach any byte in a segment by setting an offset
</p>
<p>Let's look at an example for memory segmentation.</p>
<p>
    Assume we have some code for a program loaded into memory, which is stored at 100d. To reach the first byte of
    this code we use the offset 0, and increase it for any next byte we want to access.
    We would also set the cs register to 100d as that is the starting address for the current code segment we are
    trying to run.
</p>
<p>
    x86 always runs with memory segmentation in mind, so when we use the jmp instruction, we aren't jumping to a
    specific space in memory, so let's say we write jmp 100d, we are actually jumping to the offset of 100d inside the 
    current code segment. This also happens internally with the PC (program counter), where the PC doesn't
    store the full memory address, just the offset of the next instruction.
    Any jump to a location in the same code segment is called a near jump/call, otherwise it is called a far jump
    To do far jumps, you can do stuff like "<span class="hljs">jmp 900:1d</span>", this will load 900d into the 
    CS and 1d into the PC. 
</p>
<p>
    This is exactly the same for the other two segments (data and stack), it was just easy to demonstrate using 
    and jump/call because the functionality is related to code which is easy to manipulate code flow.
    An example for DS would be lodsb, and for SS, the push instruction.
</p>
<h2 style="font-size: 20px;">How was memory segmentation used in the bootloader?</h2>
<p>
    Previously, when we wrote the bootloader (and the basic kernel) we dealt with segments, let's look at our code
    and I can now explain it now that you know everything you need to know about memory segmentation in real mode.
</p>
<p>
    The first thing we will look at goes all the way back to when we wrote our printing code together, this 
    is in the start label, here:
</p>

<pre><code>mov ax, 07C0h
mov ds, ax</code></pre>

<p>
    It's worth noting that the CS register is already set to <span class="hljs">07C0h</span> by the bootloader
    but we also set the same value to the DS register, This ensures the bootloader can correctly access it's own code and data
    correctly.
    But you might ask: "why do we need to load the location into ax and then ds?". This is because we can't directly load 
    into segment registers due to multiple limitations on the instruction set, so we just use ax as an intermediary register in order 
    to load into ds.
</p>

<p>Moving on, the next place we used memory segmentation</p>

<p>
    This is when we were trying to load the kernel into memory from the bootloader, More specifically it was when 
    we were trying to use the 13:02h interrupt, which is the interrupt for taking code from storage into memory.
    Which can all be seen in this code here: 
</p>

<pre><code>load_kernel_from_disk:
mov ax, 0900h
mov es, ax

mov ah, 02h ; service number, 
mov al, 01h ; number of sectors we want to read from (only simple kernel for now, so less than 512 bytes)

mov ch, 0h ; number of track we would like to read from, is just 0.
mov cl, 02h ; sector number that we would like to read its content, this is the second sector

mov dh, 0h ; the type of disk we would like to read from, 0h means we are reading from a floppy disk. 
mov dl, 80h ; this is the hard disk we are reading from, 80h means hard disk #0, 81h would be hard disk #1

mov bx, 0h ; memory adress that content will be loaded into
int 13h ; 13h provides services related to hard disk</code></pre>

<p>
    Here, what we do first is store 0900h into the extra segment register, as this is where we will be storing 
    the kernel in memory, you see, the interrupt 13h:02h loads the content (which we have defined with 
    prior registers) into the memory adress es:bx (where bx is the offset).
</p>

<p>
    Then after we do that we can commit a far jump to the next memory segment where the kernel will be stored.
    It's worth noting that a far jump changes the value of the cs register to wherever you jump to, in this case, it 
    will be set to 0900h, which is good because that's where the start of code segment for our kernel is.
    Then, in our kernel, we can set the ds register to the same as the cs in order to read code and data from the 
    same segment.
</p>


<h2 style="font-size: 20px;">How does memory segmentation work in protected mode? An intro to the Global Descriptor Table.</h2>

<p>
    So we have got down how memory segmentation works in real mode, and even know how it's used in our bootloader,
    that's pretty good, now we've just got to cover protected mode and we're done with memory segmentation and can move 
    onto the run time stack.
</p>


<p>
    So, the basics of memory segmentation in protected mode and real mode are basically the same.
    But, protected mode comes with some extra extensions for certain features like memory protection.
</p>

<p>
    In protected mode, we have something called the global descriptor table (GDT), this is stored in main 
    memory, and it's base address is referenced by the global descriptor table register (GDTR). Just to clarify the GDTR is a special 
    register used by the CPU to point to the location of the GDT in memory.
</p>

<p>
    Each entry in this table is called a segment descriptor, each segment descriptor has a size of 
    8 bytes and can be reffered to by an index called a segment selector. The segment selector defines an 
    offset of 8 bytes within the space defined by the GDTR.
    Each entry in the GDT defines a segment (of any type) and has the info required by the CPU to deal with that segment.
    For instance: The starting memory address of the segment is stored, the size/limit of the segment is stored.
</p>

<p>
    Furthermore, as we have this focus around the GDT, our segment registers from real mode no longer store direct addresses,
    they store segment selectors.
</p>

<h4>The structure of the segment descriptor, a basic overview.</h4>

<p>
    As we said before, a segment descriptor is an entry of the GDT worth 8 bytes, it is made up of multiple fields and flags that describe the attributes of any 
    segment in memory. The processor will then go to the descriptor that describes the segment when we need to obtain information about a segment, like the starting memory address (of said segment).
    Aswell as storing basic info, a segment descriptor stores info that helps in memory protection, this makes memory segmentation not just a logical way of viewing memory, but a method of memory protection,
    protecting different segments on the system from each other, and not letting a less privileged segments manipulate data or call code in certain places (typically more privileged areas of the system).

</p>

<h4>How segments are used when calling and interacting with other memory.</h4>

<p>
    The most important information about a segment is it's base address (the starting memory address). In real mode, the base address was stored in the corresponding segment register directly,
    but in protected mode, this is just stored in the segment descriptor.
</p>

<p>
    When currently running code refers to a memory address to read from or write to (with data segments) or to call somewhere (with code segments). it is actually referencing a specific
    segment in the system and an offset. This generated memory address that we get when we try to look somewhere in a different segment, is not a physical memory adress, it is actually a logical memory address,
    meaning it doesn't actually reference the place in which data is stored, it is simply a logical representation of where we need to go relative to the program's address space.
    In this case, a logical memory address is a segment selector and offset, to point to the memory location we want to go.
</p>

<p>
    Every logical memory address refers to some byte in the specific segment in the system, and to actually reference this, it needs to be translated into a physical memory address.
</p>

<p>
    In x86, a logical memory address may go through two translation processes instead of one, to obtain a physical memory address.
    The first step: involves turning the logical memory address into a linear memory address (another non physical memory address) which is here becuase of the paging feature. If paging is enables in
    the system, a second translation process occurs to turn the linear memory addresss into a physical memory address, this is becauase a linear memory address can be seen as a physical address when paging is disabled.
    But not when it is enabled. So for now, we will only focus on the process to turn a logical memory address into a linear memory address.
</p>

<p>
    So, we know that each logical address consists of two parts, a 16 bit segment selector and a 32 bit offset. When this is logical adress is generated by currently running code, the proccessor then 
    needs to ranslate it to get the physical address, as has been said.
</p>

<p>
    First we read the value of the register GDTR (which contains the starting physical memory address to locate the descriptor of the GDT), then we use the segment selector in the logical
    memory address in order to locate the descriptor of the segment, this descriptor then contains the base address of the segment, the proccessor then obtains this base address, and adds it to the offset,
    this provides ups with the linear memory address.
</p>

<h4>Memory protection in this process, and segment limits.</h4>

<p>
    During this process of translation, other information from the segment descriptor is used to provide memory protection. One of these pieces of information is called the limit of a segment,
    this means a segment's size, if the generated code refers to an offset which exceeds the limit of a segment, the proccessor will stop this operation.
</p>

<p>
    The limit of a segment is stored in the 20 bit "segment limit field" of a segment descriptor, how to processor interprets the value of the segment limit field depends on the 
    granularity flag (G flag), which is also stored in the segment's descriptor. When the value of the G flag is 0, this means te value of the limit field is interpreted as bytes.
    So if the G flag is set to 0 and the segment limit field is 20, the size of the segment is seen as 20 bytes. On the other hand, when it 
    is set to 1, the value of the segment limit field will be interpreted as 4KB units. To see what this means, assume the value of the limit field is 20, but the G flag is 1, this means that the size 
    of the segment will be 20 of 4KB units, so 20*4 = 80, so the size of the segment is 80KB, (81920 bytes).
</p>

<p>
    Because the size of the segment limit field is 20 bits, this means that the max numeric value it can represent is 2^20, this means that is the G flag is 0, the mximum size is 1MB, and if
    it's set to 1, the maximum size is 4 GB.
</p>

<h4>Back to the structure of the descriptor, looking more in depth.</h4>

<p>
    maybe do later....
</p>

<h4>A segment's type</h4>

<p>
    When a segment is defined, the processor should know how to interpret the content inside this segment, this is defined by the type of segment. We know so far that there are code segments 
    and data segments, these two types belong to a category of segments called application segments, there is another category called system segments, and many types of segment belong to it.
</p>

<p>
    Whether a specific segment is an application or system segment, is defined in the S flag, also known as the descriptor type flag, which is the fifth bit in the fifth byte of the segment descriptor.
    When the S flag is 0, the segment is considered a system segment, when it is an application segment the value of S is 1. We will focus on when the S flag is 1.
</p>
 
<p>
    The only application segments are code and data. If some application segment is referenced by currently running code, the proccessor will go to the descriptor of this segment, 
    and by reading the S flag (which sould be 1), it should know that the segment in question is an application segment, but how does it know whether it's a data or code segment?
    This info is stored in a field called the type field in the segment descriptor.
</p>

<p>
    The type field is the first 4 bits of the 5th byte of the segment descriptor. The most significant bit specifies if the application segment is a code or data segment, the least significant 
    specifies whether the segment has been accessed or not, when the value of this is 1, this means that the segment has been written to or read from, but if it's 0, this means that the segment 
    has not been accessed. The value of this bit is changed by the proccessor in only one situation, this is when the selector of the segment is loaded into the GDT. In any other situation, 
    it's up to the OS to decide the value of the accessed flag. According to intel, this flag can be used for virtual memory management and debugging.
</p>

<p>
    The other two bits or flags of the type field depend on whether it's a code or data segment. So let's cover those individually.
</p>

<h4>The type field for Code segments</h4>

<p>
    When the segment is a code segment
</p>


WRITE ABOUT HOW A LOGICAL MEMORY ADRESS IS A SEGMENT ESELECTOR AND OFFSET. AND HOW CONVERSION RELIES ON CHECKING THE SEGMENT DESCRIPTOR.
Continue on page 52

PAGE 53